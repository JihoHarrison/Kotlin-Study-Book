## 코틀린의 철학

공부 자료 : Kotlin In Action 1장 - 코틀린이란 무엇이며, 왜 필요한가?

<br></br>

### 01 - 코틀린의 철학 4가지

- 실용성
- 간결성
- 안전성
- 상호운용성

<br></br>

### 02 - 코틀린은 실용적인 언어임을 보장한다.

- `실용적이다` = 실제로 사용할 때 유용하다.
- 코틀린은 실제 문제를 해결할 때 사용될 수 있도록 만들어진 언어다.
- = 연구용 언어가 아니다.
- 코틀린 언어 설계의 바탕
  - IT 업계의 다년간 경험을 바탕으로 설계되었다.
  - 젯브레인스나 코틀린 커뮤니티 내부 개발자들이 코틀린 초기 버전을 다년간 사용하며 피드백했다.
  - 피드백들이 반영된 버전이 최종 코틀린 언어로 배포되었다.
- 코틀린의 실용성
  - 프로젝트에서 실제 문제를 해결할 때 코틀린을 사용하면 문제 해결에 도움이 되어야 한다.
  - 코틀린은 연구를 위한 언어가 아니다.
  - 실제 프로덕트를 만들 때 사용하도록 설계된 언어다.
- 코틀린을 사용해서 문제를 해결하면 쉬운 이유
  - 코틀린은 도구를 강조하는 언어다.
  - 편리한 개발 환경까지 챙기는 언어다.
  - IDE에서 사용할 수 있는 코틀린 언어 지원 도구와 컴파일러 개발이 코틀린 언어 개발과 동시에 이루어졌다.
  - `코틀린 언어 지원 도구` = `코틀린 플러그인`
  - IDE에 코틀린 플러그인을 껴서 사용하면 더 쉽게 문제를 해결할 수 있다.
  - 예시 ) 더 간결한 구조 또는 더 좋은 코드 패턴으로 바꿀 수 있는 곳을 IDE가 감지하여 수정하라고 제안한다.
  - = 문제 해결 과정에서 도움을 주는 실용적인 언어다.
  - 안드로이드 스튜디오를 사용하는 개발자라면 플러그인 관리 창에서 Kotlin 플러그인을 설치한 후 사용할 수 있다.

![image](https://user-images.githubusercontent.com/31889335/139538663-ae06875f-ec24-4636-98a8-fa1d8be4fde7.png)

<br></br>

### 03 - 코틀린은 간결한 언어임을 보장한다.

- `간결하다` = 코드가 간단하고 내용을 파악하기 쉽다.
- 보통 다른 사람이 작성한 코드를 분석하는데 시간이 오래 걸린다.
- 코틀린의 간결성
  - 이미 작성되어 있는 코드를 읽을 때 의도를 쉽게 파악할 수 있도록 도와주는 구문들을 제공한다.
  - 자바의 `getter`, `setter` 를 코틀린은 묵시적으로 제공한다.
  - = getter, setter 작성할 필요 없다.
  - = 코드가 길어지는 원인을 해결하여 짧에 작성할 수 있도록 설계되었다.
  - 코틀린은 생성자 파라미터를 필드에 대입하기 위한 로직을 묵시적으로 제공한다.
  - 코틀린은 여러 가지 기능이 있는 `표준 라이브러리`를 제공한다.
  - 표준 라이브러리에서 제공하는 것들을 사용하면 코드를 더 읽기 쉽고 간결하게 작성할 수 있다.
  - 코틀린은 `람다`를 제공하기 때문에 작은 함수 코드 블럭을 쉽게 만들 수 있다.
  - 읽기 쉽도록 연산자의 이름을 기호가 아닌 단어로 제공한다.

<br></br>

### 04 - 코틀린은 안전한 언어임을 보장한다.

- `프로그래밍 언어가 안전하다` = 프로그램에서 발생할 수 있는 오류 중 일부 유형의 오류를 프로그램 개발 시점에서 방지할 수 있다.
- 어떤 언어도 모든 오류를 개발 과정에서 막을 수는 없다.
- = 사용자에게 프로그램이 제공된 후에야 오류가 발생하는 경우가 많다.
- 사용자에게 제공되기 전, 최대한 많은 오류를 개발 과정에서 막을 수 있는 언어가 안전성을 띄는 언어다.
- 코틀린의 안전성
  - 자바보다 더 높은 수준의 안전성을 달성하도록 설계되었다.
  - 코틀린은 `JVM` 에서 실행된다.
  - JVM은 메모리 안전성을 보장하고, 버퍼 오버플로를 방지해준다.
- 코틀린이 방지해주는 예외들
  - 코틀린은 `NullPointerException`을 컴파일 시점에 방지해준다.
  - 코틀린의 타입 시스템은 null이 될 수 없는 값을 추적한다.
  - NPE가 발생할 수 있는 연산을 사용하는 코드를 금지한다.
  - 코틀린은 `ClassCastException`을 컴파일 시점에 방지해준다.
  - 어떤 객체를 다른 타입으로 강제 형 변환(cast)하기 전에 형 변환 가능한지 타입을 미리 검사하지 않고 변환을 해버리면 ClassCastException이 발생할 수 있다.
  - 자바는 타입 검사를 하고 다시 캐스트를 해주는 코드가 길다.
  - 귀찮은 개발자들은 타입 검사를 해주지 않고 강제 형 변환을 하는 경우가 있다.
  - 코틀린은 하나의 연산자가 타입 검사와 캐스트를 모두 실행해준다.
~~~kotlin
/* 코틀린의 null 타입 시스템 */

val name: String? = null // 컴파일러가 변수 name은 null이 될 수 있다고 판단한다.

val name2: String = "" // 컴파일러가 변수 name은 null이 될 수 없다고 판단한다.

name2 = null // 컴파일러가 null이 될 수 없는 변수에 null이 들어갔다고 알려준다.
~~~
~~~java
/* 자바의 강제 형 변환 코드 */
class List {
    public void test() {}
}
class ArrayList extends List {}


public static void main(String[] args) {
    List list = new List()
    ArrayList arrayList = new ArrayList()

    println(list instanceof List) // true = list를 List 타입으로 형 변환 가능
    println(arrayList instanceof ArrayList) // true = arrayList를 ArrayList 타입으로 형 변환 가능
    println(arrayList instanceof List) // true = arrayList를 List 타입으로 형 변환 가능
    println(list instanceof ArrayList) // false = list를 ArrayList 타입으로 형 변환 불가능

    if (arrayList instanceof List) { // 타입 검사
        (List)arrayList.test() // 직접 형 변환 해줘야 한다.
    }
}
~~~
- 위 코드 설명
  - 자바에서 강제 형 변환을 하려면 형 변환을 하기 전에 `instanceof` 연산자로 타입 검사를 해야 한다.
  - = 형 변환 가능한지 검사하는 것이다.
  - 타입 검사를 하지 않고 강제 형 변환을 하면,
  - 개발자의 실수로 형 변환이 불가능한 클래스로 강제 형 변환을 하는 코드를 작성할 수 있다.
  - 이 경우 ClassCastException 예외가 발생한다.
  - 타입 검사에서 통과해서 강제 형 변환이 가능할 경우,
  - 변환된 타입의 클래스 메소드를 사용할 수 있다.
~~~kotlin
/* 코틀린의 강제 형 변환 코드 */
...

fun main() {
    val list = List()
    val arrayList = arrayList()

    if (arrayList is List) {  // 타입 검사 + 형 변환
        arrayList.test() // 바로 사용 가능
    }
}
~~~
- 위 코드 설명
  - 코틀린에서 제공하는 `is` 연산자를 사용하여 타입 검사와 형 변환을 한 번에 할 수 있다.

<br></br>

### 05 - 코틀린은 상호운용성이 높은 언어임을 보장한다.

- `상호운용성` = 코틀린과 자바가 호환되는가
- 자바로 개발된 기존 라이브러리들을 그대로 사용할 수 있다.
- 자바로 개발된 라이브러리가 어떤 API를 제공하던 간에 코틀린에서 그 API를 사용할 수 있다.
- 코틀린과 자바가 어디까지 호환되는가
  - 자바 메소드를 코틀린 코드로 호출 가능하다.
  - 자바로 작성된 클래스를 상속한 코틀린 클래스를 만들 수 있다.
  - 자바로 작성된 인터페이스를 코틀린으로 구현할 수 있다.
  - 자바 어노테이션을 코틀린 코드에 적용할 수 있다.
  - 자바 코드에서 코틀린 코드를 호출할 수 있다.
- 코틀린은 자바 라이브러리를 최대한 활용한다.
  - 코틀린에는 Collection 라이브러리가 없다.
  - 자바의 Collection 라이브러리를 최대한 활용하기 위해서다.
  - 대신, 코틀린에서 자바 Collection 라이브러리를 더 쉽게 활용할 수 있도록 확장 API들을 제공한다.
  - Collection 라이브러리 외에도 다양한 자바 라이브러리를 더 쉽게 사용할 수 있다.
  - 예시 ) 자바의 `System.out.println()` 대신 `println()`이라고 쓴다.
  - = 코틀린 표준 라이브러리는 자바 라이브러리에서 제공하는 함수를 더 간결하게 사용할 수 있게 감싼 `wrapper`를 제공한다.
  

<br></br>

# 공부 끝~ 🏃🏻‍♀️