## while과 for 루프


### while 루프
 - 이 부분 또한 코틀린의 특성 중 자바와 가장 비슷한 특성을 가지고 있다.
 - 자바와 동일하게 while과 do-while 루프가 있는데 자바와 사용 방법이 동일하다.
~~~kotlin
while(조건) {
    /*...*/
}
do {
    /*...*/
} while(조건)
~~~
 - 더 이상 살펴볼 것이 없다. 그냥 자바랑 동일하다.

### for 루프
 - 자바에서의 for 루프의 정의는 어떤 변수를 초기화 하고 그 변수를 루프를 한 번 돌 때마다 갱신하고 루프 조건이 거짓이 될 때 반복을 마치는 형태를 말한다.
 - 하지만 코틀린은 이러한 조건을 만족하는 for 루프는 존재하지 않는다. 이런 루프의 가장 흔한 용례인 초기, 증가, 최종 값의 개념을 대신하기 위해 코틀린은 `범위`라는 개념을 사용한다.
 - 범위는 기본적으로 두 값으로 이루어진 형태이고 시작 값과 끝 값을 연결하여 생성된다. 코틀린에서는 `..` 연산자를 이용하여 두 수의 범위를 만들고 이 때 끝 값은 범위 안에 포함되어 있는 형태이다.
~~~kotlin
fun threeFiveGame(i : Int) = when {
    i % 15 == 0 -> "3 and 5"
    i % 5 == 0 -> "5"
    i % 3 == 0 -> "3"
}

for(i in 1..100) {
    println(threeFiveGame(i))
}
~~~
#### 위 코드 설명
 - 인자가 없는 when절 안에 모듈러 연산자를 사용해 각 숫자로 나누어 떨어지면 그에 맞는 조건에 해당하는 문자열을 반환하는 함수가 있고, 1부터 100까지 `for`루프를 돌면서 조건을 출력 해 준다.

#### 증가 값을 가지고 범위 이터레이션
~~~kotlin
for(i in 100 downTo 1 step 2) {
    print(threeFiveGame(i))
}
~~~
 - 여기서는 증가값 step을 가지는 수열에 대한 이터레이션이 존재한다. 증가 값을 사용하면 수를 건너 뛸 수 있다. 증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다. 이 예제에서 `100 downTo 1`은 역방향 수열을 만든다. 그 뒤에 `step 2`를 붙이게 되면 등가 값의 절대값이 2로 바뀐다.
 - 하지만 여기서 끝 값을 포함하지 않는 범위에 대해 이터레이션을 만들려면 `..` 연산자를 `until` 연산자로 바꾸기만 하면 끝 값을 포함하지 않는 이터레이션을 만들게 된다.

<br><br>